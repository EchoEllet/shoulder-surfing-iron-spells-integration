plugins {
    `java-library`
    alias(libs.plugins.neoforgeGradle)
    idea
    alias(libs.plugins.modrinthMinotaur)
}

tasks.named<Wrapper>("wrapper") {
    distributionType = Wrapper.DistributionType.BIN
}

version = libs.versions.mod.get()
group = "mod.shoulder_surfing"

val modGroupId = group as String
val modId = "shoulder_surfing_irons_spells_integration"
val modVersion = version as String
val neoforgeVersion = libs.versions.neoforge.get()
val mcVersion = libs.versions.minecraft.get()
val javaVersion = libs.versions.java.get().toInt()

repositories {
    fun strictMaven(url: String, includeGroup: String, name: String) {
        exclusiveContent {
            forRepository {
                maven {
                    this.name = name
                    this.url = uri(url)
                }
            }
            filter {
                includeGroup(includeGroup)
            }
        }
    }
    strictMaven(
        url = "https://api.modrinth.com/maven",
        name = "Modrinth",
        includeGroup = "maven.modrinth"
    )
    strictMaven(
        url = "https://cursemaven.com",
        name = "CurseMaven",
        includeGroup = "curse.maven"
    )
    strictMaven(
        url = "https://code.redspace.io/releases",
        name = "Redspace Release",
        includeGroup = "io.redspace"
    )
    strictMaven(
        url = "https://maven.theillusivec4.top/",
        name = "Caelus",
        includeGroup = "com.illusivesoulworks.caelus"
    )
    strictMaven(
        url = "https://dl.cloudsmith.io/public/geckolib3/geckolib/maven/",
        name = "GeckoLib",
        includeGroup = "software.bernie.geckolib"
    )
    strictMaven(
        url = "https://maven.kosmx.dev/",
        name = "KosmX",
        includeGroup = "dev.kosmx.player-anim"
    )
    strictMaven(
        url = "https://maven.theillusivec4.top/",
        name = "Curios",
        includeGroup = "top.theillusivec4.curios"
    )
}

base {
    archivesName = modId
    version = "${modVersion}-mc${mcVersion}-neoforge"
}

java {
    withSourcesJar()

    toolchain.languageVersion = JavaLanguageVersion.of(javaVersion)
}

val sourcesJar by tasks.getting(Jar::class)

neoForge {
    version = neoforgeVersion

    parchment {
        mappingsVersion = libs.versions.parchmentMappings.get()
        minecraftVersion = libs.versions.minecraft.get()
    }

    runs {
        create("client") {
            client()
            systemProperty("neoforge.enabledGameTestNamespaces", modId)
        }

        create("server") {
            server()
            programArgument("--nogui")
            systemProperty("neoforge.enabledGameTestNamespaces", modId)
        }

        create("gameTestServer") {
            type = "gameTestServer"
            systemProperty("neoforge.enabledGameTestNamespaces", modId)
        }

        create("data") {
            data()
            programArguments.addAll(
                "--mod", modId,
                "--all",
                "--output", file("src/generated/resources/").absolutePath,
                "--existing", file("src/main/resources/").absolutePath
            )
        }

        configureEach {
            systemProperty("forge.logging.markers", "REGISTRIES")
            logLevel = org.slf4j.event.Level.DEBUG
        }
    }

    mods {
        register(modId) {
            sourceSet(sourceSets.main.get())
        }
    }
}

// Include resources generated by data generators.
sourceSets.main {
    resources.srcDir(layout.projectDirectory.dir("src/generated/resources"))
}

configurations {
    val localRuntime by creating

    runtimeClasspath {
        extendsFrom(localRuntime)
    }
}

dependencies {
    implementation(libs.shoulderSurfingReloaded)

    // This mod provides an API for mod developers.
    // We aim to rely solely on the official mod API, but creating a reliable, client-side-only mod
    // that is also compatible with controller mods—without sending network packets—is challenging without hacks.
    // Therefore, we depend on the internal implementation of the mod.
    implementation(libs.ironsSpellbooks)

    val localRuntime by configurations.getting

    // Iron spells dependencies
    localRuntime(libs.caelus)
    localRuntime(libs.playerAnimationLib)
    localRuntime(libs.curios)
    localRuntime(libs.geckolib)

    // For testing compatibility with controller mods
    localRuntime(libs.controllable)
    localRuntime(libs.framework)

    // For testing compatibility with Epic fight mod
    localRuntime(libs.epicfight)
}

val generationTaskGroup = "generation"

val generateModMetadata by tasks.registering(ProcessResources::class) {
    group = generationTaskGroup

    val replaceProperties = mapOf(
        "minecraft_version_range" to libs.versions.minecraftRange.get(),
        "neoforge_version_range" to libs.versions.neoforgeRange.get(),
        "loader_version_range" to libs.versions.javaFmlLoaderRange.get(),
        "ironsSpellbooks_version_range" to libs.versions.ironsSpellbooksRange.get(),
        "shouldersurfing_version_range" to libs.versions.shoulderSurfingReloadedRange.get(),
        "mod_id" to modId,
        "mod_version" to modVersion
    )
    inputs.properties(replaceProperties)
    expand(replaceProperties)
    from("src/main/templates")
    into("build/generated/sources/modMetadata")
}

sourceSets.main {
    resources.srcDir(generateModMetadata.map { it.outputs.files.singleFile })
}
neoForge.ideSyncTask(generateModMetadata)

tasks.withType<JavaCompile>().configureEach {
    options.encoding = "UTF-8"
}

// IDEA no longer automatically downloads sources/javadoc jars for dependencies, so we need to explicitly enable the behavior.
idea {
    module {
        isDownloadSources = true
        isDownloadJavadoc = true
    }
}

fun extractCurrentVersionChangelog(): String {
    val changelogFile = rootProject.file("CHANGELOG.md")
    val fullChangelogText = changelogFile.readText()

    val versionSectionRegex = Regex("(?s)## \\[$modVersion].*?(?=\\n## \\[|\\z)")

    val versionSection = versionSectionRegex.find(fullChangelogText)
        ?.value
        ?.trim()
        ?: error("No changelog found for version $modVersion")

    val versionChangelog = versionSection.lineSequence()
        .drop(1) // skip the heading line
        .joinToString("\n")
        .trim()
    return versionChangelog
}

fun buildReleaseChangeLog(currentVersionChangelog: String): String {
    return buildString {
        append(currentVersionChangelog)
        append("\n\n")
        append(
            """
    **Tested against:**
    - **NeoForge:** $neoforgeVersion
    - **Minecraft:** $mcVersion
    - **Shoulder Surfing Reloaded:** ${libs.versions.shoulderSurfingReloaded.get()}
    - **Iron's Spells 'n Spellbooks:** ${libs.versions.ironsSpellbooks.get()}
    """.trimIndent()
        )
    }
}

modrinth {
    val modrinthToken: String? = System.getenv("MODRINTH_TOKEN")
    debugMode.set(modrinthToken == null)
    token.set(modrinthToken)
    projectId.set("shoulder-surfing-iron-spells-integration")
    versionNumber.set(modVersion)
    versionType.set("release")
    versionName.set("[NeoForge ${libs.versions.minecraft.get()}] v${modVersion}")
    uploadFile.set(tasks.jar)
    additionalFiles.add(sourcesJar)
    gameVersions.addAll(libs.versions.minecraft.get())
    loaders.add("neoforge")
    dependencies {
        required.project("shoulder-surfing-reloaded")
        required.project("irons-spells-n-spellbooks")
    }

    changelog.set(buildReleaseChangeLog(extractCurrentVersionChangelog()))

    syncBodyFrom = rootProject.file("README.md").readText()
}
