plugins {
    `java-library`
    alias(libs.plugins.forgeGradle)
    alias(libs.plugins.parchmentForgeGradle)
    alias(libs.plugins.spongepowered)
    idea
    alias(libs.plugins.modrinthMinotaur)
}

tasks.named<Wrapper>("wrapper") {
    distributionType = Wrapper.DistributionType.BIN
}

version = libs.versions.mod.get()
group = "mod.shoulder_surfing"

val modGroupId = group as String
val modId = "shoulder_surfing_irons_spells_integration"
val modVersion = version as String
val forgeVersion = libs.versions.forge.get()
val mcVersion = libs.versions.minecraft.get()
val javaVersion = libs.versions.java.get().toInt()

repositories {
    fun strictMaven(url: String, includeGroup: String, name: String) {
        exclusiveContent {
            forRepository {
                maven {
                    this.name = name
                    this.url = uri(url)
                }
            }
            forRepositories(fg.repository)
            filter {
                includeGroup(includeGroup)
            }
        }
    }
    strictMaven(
        url = "https://api.modrinth.com/maven",
        name = "Modrinth",
        includeGroup = "maven.modrinth"
    )
    strictMaven(
        url = "https://cursemaven.com",
        name = "CurseMaven",
        includeGroup = "curse.maven"
    )
    strictMaven(
        url = "https://code.redspace.io/releases",
        name = "Redspace Release",
        includeGroup = "io.redspace.ironsspellbooks"
    )
    strictMaven(
        url = "https://maven.theillusivec4.top/",
        name = "Caelus",
        includeGroup = "top.theillusivec4.caelus"
    )
    strictMaven(
        url = "https://dl.cloudsmith.io/public/geckolib3/geckolib/maven/",
        name = "GeckoLib",
        includeGroup = "software.bernie.geckolib"
    )
    strictMaven(
        url = "https://maven.kosmx.dev/",
        name = "KosmX",
        includeGroup = "dev.kosmx.player-anim"
    )
    strictMaven(
        url = "https://maven.theillusivec4.top/",
        name = "Curios",
        includeGroup = "top.theillusivec4.curios"
    )
}

base {
    archivesName = modId
    version = getFullModVersion()
}

fun getFullModVersion(): String = "${modVersion}-mc${mcVersion}-forge"

java {
    withSourcesJar()

    toolchain.languageVersion = JavaLanguageVersion.of(javaVersion)
}

val sourcesJar by tasks.getting(Jar::class)

minecraft {
    mappings("parchment", "${libs.versions.parchmentMappings.get()}-${libs.versions.minecraft.get()}")

    copyIdeResources.set(true)

    runs {
        configureEach {
            workingDirectory = "run"
            property("forge.logging.markers", "REGISTRIES")
            property("forge.logging.console.level", "debug")

            mods {
                create(modId) {
                    source(sourceSets.main.get())
                }
            }
        }

        create("client") {
            property("forge.enabledGameTestNamespaces", modId)
        }

        create("server") {
            property("forge.enabledGameTestNamespaces", modId)
            args("--nogui")
        }

        create("gameTestServer") {
            property("forge.enabledGameTestNamespaces", modId)
        }

        create("data") {
            workingDirectory = "run-data"
            args(
                "--mod", modId,
                "--all",
                "--output", file("src/generated/resources/").absolutePath,
                "--existing", file("src/main/resources/").absolutePath
            )
        }
    }
}

mixin {
    add(sourceSets.main.get(), "$modId.refmap.json")
    config("$modId.mixins.json")
}

// Include resources generated by data generators.
sourceSets.main {
    resources.srcDir(layout.projectDirectory.dir("src/generated/resources"))
}

configurations {
    val localRuntime by creating

    runtimeClasspath {
        extendsFrom(localRuntime)
    }
}

dependencies {
    minecraft("net.minecraftforge:forge:${libs.versions.minecraft.get()}-${libs.versions.forge.get()}")
    annotationProcessor("org.spongepowered:mixin:${libs.versions.spongepoweredProcessor.get()}:processor")

    implementation(fg.deobf(libs.shoulderSurfingReloaded))

    // This mod provides an API for mod developers.
    // We aim to rely solely on the official mod API, but creating a reliable, client-side-only mod
    // that is also compatible with controller mods—without sending network packets—is challenging without hacks.
    // Therefore, we depend on the internal implementation of the mod.
    implementation(fg.deobf(libs.ironsSpellbooks))

    val localRuntime by configurations.getting

    // Iron spells dependencies
    localRuntime(fg.deobf(libs.caelus))
    localRuntime(fg.deobf(libs.playerAnimationLib))
    localRuntime(fg.deobf(libs.curios))
    localRuntime(fg.deobf(libs.geckolib))

    // For testing compatibility with controller mods
    localRuntime(fg.deobf(libs.controllable))
    localRuntime(fg.deobf(libs.framework))

    // For testing compatibility with Epic fight mod
    localRuntime(fg.deobf(libs.epicfight))
}

val generationTaskGroup = "generation"

val generateModMetadata by tasks.registering(ProcessResources::class) {
    group = generationTaskGroup

    val replaceProperties = mapOf(
        "minecraft_version_range" to libs.versions.minecraftRange.get(),
        "forge_version_range" to libs.versions.forgeRange.get(),
        "loader_version_range" to libs.versions.javaFmlLoaderRange.get(),
        "ironsSpellbooks_version_range" to libs.versions.ironsSpellbooksRange.get(),
        "shouldersurfing_version_range" to libs.versions.shoulderSurfingReloadedRange.get(),
        "mod_id" to modId,
        "mod_version" to modVersion
    )
    inputs.properties(replaceProperties)
    expand(replaceProperties)
    from("src/main/templates")
    into("build/generated/sources/modMetadata")
}

sourceSets.main {
    resources.srcDir(generateModMetadata.map { it.outputs.files.singleFile })
}
tasks.processResources {
    dependsOn(generateModMetadata)
}

tasks.withType<JavaCompile>().configureEach {
    options.encoding = "UTF-8"
}

// IDEA no longer automatically downloads sources/javadoc jars for dependencies, so we need to explicitly enable the behavior.
idea {
    module {
        isDownloadSources = true
        isDownloadJavadoc = true
    }
}

fun extractCurrentVersionChangelog(): String {
    val changelogFile = rootProject.file("CHANGELOG.md")
    val fullChangelogText = changelogFile.readText()

    val versionSectionRegex = Regex("(?s)## \\[$modVersion].*?(?=\\n## \\[|\\z)")

    val versionSection = versionSectionRegex.find(fullChangelogText)
        ?.value
        ?.trim()
        ?: error("No changelog found for version $modVersion")

    val versionChangelog = versionSection.lineSequence()
        .drop(1) // skip the heading line
        .joinToString("\n")
        .trim()
    return versionChangelog
}

fun buildReleaseChangeLog(currentVersionChangelog: String): String {
    return buildString {
        append(currentVersionChangelog)
        append("\n\n")
        append(
            """
    **Tested against:**
    - **Forge:** $forgeVersion
    - **Minecraft:** $mcVersion
    - **Shoulder Surfing Reloaded:** ${libs.versions.shoulderSurfingReloaded.get()}
    - **Iron's Spells 'n Spellbooks:** ${libs.versions.ironsSpellbooks.get()}
    """.trimIndent()
        )
    }
}

modrinth {
    val modrinthToken: String? = System.getenv("MODRINTH_TOKEN")
    debugMode.set(modrinthToken == null)
    token.set(modrinthToken)
    projectId.set("shoulder-surfing-iron-spells-integration")
    versionNumber.set(getFullModVersion())
    versionType.set("release")
    versionName.set("[Forge ${libs.versions.minecraft.get()}] v${modVersion}")
    uploadFile.set(tasks.jar)
    additionalFiles.add(sourcesJar)
    gameVersions.addAll(libs.versions.minecraft.get())
    loaders.add("forge")
    dependencies {
        required.project("shoulder-surfing-reloaded")
        required.project("irons-spells-n-spellbooks")
    }

    changelog.set(buildReleaseChangeLog(extractCurrentVersionChangelog()))

    syncBodyFrom = rootProject.file("README.md").readText()
}
