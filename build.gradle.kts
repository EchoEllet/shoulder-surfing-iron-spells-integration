plugins {
    `java-library`
    alias(libs.plugins.neoforgeGradle)
    idea
}

tasks.named<Wrapper>("wrapper") {
    distributionType = Wrapper.DistributionType.BIN
}

version = libs.versions.mod.get()
group = "mod.shoulder_surfing"

val modGroupId = group as String
val modId = "shoulder_surfing_irons_spells_integration"
val modVersion = version as String
val neoforgeVersion = libs.versions.neoforge.get()
val mcVersion = libs.versions.minecraft.get()
val javaVersion = libs.versions.java.get().toInt()

repositories {
    exclusiveContent {
        forRepository {
            maven { name = "Modrinth"; url = uri("https://api.modrinth.com/maven") }
        }
        filter { includeGroup("maven.modrinth") }
    }

    exclusiveContent {
        forRepository {
            maven { url = uri("https://cursemaven.com") }
        }
        filter { includeGroup("curse.maven") }
    }

    exclusiveContent {
        forRepository {
            maven { url = uri("https://code.redspace.io/releases") }
        }
        filter { includeGroup("io.redspace") }
    }

    exclusiveContent {
        forRepository {
            maven { url = uri("https://maven.theillusivec4.top/") }
        }
        filter { includeGroup("com.illusivesoulworks.caelus") }
    }

    exclusiveContent {
        forRepository {
            maven { url = uri("https://dl.cloudsmith.io/public/geckolib3/geckolib/maven/") }
        }
        filter { includeGroup("software.bernie.geckolib") }
    }

    exclusiveContent {
        forRepository {
            maven { url = uri("https://maven.kosmx.dev/") }
        }
        filter { includeGroup("dev.kosmx.player-anim") }
    }

    exclusiveContent {
        forRepository {
            maven { url = uri("https://maven.theillusivec4.top/") }
        }
        filter { includeGroup("top.theillusivec4.curios") }
    }
}

base {
    archivesName = modId
    version = "${modVersion}-mc${mcVersion}-neoforge"
}

java.toolchain.languageVersion = JavaLanguageVersion.of(javaVersion)

neoForge {
    version = neoforgeVersion

    parchment {
        mappingsVersion = libs.versions.parchmentMappings.get()
        minecraftVersion = libs.versions.minecraft.get()
    }

    runs {
        create("client") {
            client()
            systemProperty("neoforge.enabledGameTestNamespaces", modId)
        }

        create("server") {
            server()
            programArgument("--nogui")
            systemProperty("neoforge.enabledGameTestNamespaces", modId)
        }

        create("gameTestServer") {
            type = "gameTestServer"
            systemProperty("neoforge.enabledGameTestNamespaces", modId)
        }

        create("data") {
            data()
            programArguments.addAll(
                "--mod", modId,
                "--all",
                "--output", file("src/generated/resources/").absolutePath,
                "--existing", file("src/main/resources/").absolutePath
            )
        }

        configureEach {
            systemProperty("forge.logging.markers", "REGISTRIES")
            logLevel = org.slf4j.event.Level.DEBUG
        }
    }

    mods {
        register(modId) {
            sourceSet(sourceSets.main.get())
        }
    }
}

// Include resources generated by data generators.
sourceSets.main {
    resources.srcDir(layout.projectDirectory.dir("src/generated/resources"))
}

configurations {
    val localRuntime by creating

    runtimeClasspath {
        extendsFrom(localRuntime)
    }
}

dependencies {
    implementation(libs.shoulderSurfingReloaded)

    // This mod provides an API for mod developers.
    // We aim to rely solely on the official mod API, but creating a reliable, client-side-only mod
    // that is also compatible with controller mods—without sending network packets—is challenging without hacks.
    // Therefore, we depend on the internal implementation of the mod.
    implementation(libs.ironsSpellbooks)

    val localRuntime by configurations.getting

    // Iron spells dependencies
    localRuntime(libs.caelus)
    localRuntime(libs.playerAnimationLib)
    localRuntime(libs.curios)
    localRuntime(libs.geckolib)

    // For testing compatibility with controller mods
    localRuntime(libs.controllable)
    localRuntime(libs.framework)

    // For testing compatibility with Epic fight mod
    localRuntime(libs.epicfight)
}

val generationTaskGroup = "generation"

val generateModMetadata by tasks.registering(ProcessResources::class) {
    group = generationTaskGroup

    val replaceProperties = mapOf(
        "minecraft_version_range" to libs.versions.minecraftRange.get(),
        "neoforge_version_range" to libs.versions.neoforgeRange.get(),
        "loader_version_range" to libs.versions.javaFmlLoaderRange.get(),
        "ironsSpellbooks_version_range" to libs.versions.ironsSpellbooksRange.get(),
        "shouldersurfing_version_range" to libs.versions.shoulderSurfingReloadedRange.get(),
        "mod_id" to modId,
        "mod_version" to modVersion
    )
    inputs.properties(replaceProperties)
    expand(replaceProperties)
    from("src/main/templates")
    into("build/generated/sources/modMetadata")
}

sourceSets.main {
    resources.srcDir(generateModMetadata.map { it.outputs.files.singleFile })
}
neoForge.ideSyncTask(generateModMetadata)

tasks.withType<JavaCompile>().configureEach {
    options.encoding = "UTF-8"
}

// IDEA no longer automatically downloads sources/javadoc jars for dependencies, so we need to explicitly enable the behavior.
idea {
    module {
        isDownloadSources = true
        isDownloadJavadoc = true
    }
}
